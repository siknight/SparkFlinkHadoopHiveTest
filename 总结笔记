idea常用快捷键总结:
liunx软件安装：
    mysql需要rpm，其他的直接解压
hadoop总结:（不用配zookeeper，除了HA）
    1.hdfs是分布式存储框架
        （1）hadoop= hdfs + yarn + mapreduce + common
            命令hdfs dfs -命令（用hdfs dfs可以查看所有命令）
                  或者 hadoop fs -命令（用hadoop fs可以查看所有命令）
        （2）连接到hdfs的url: hdfs://hadoop102:9000
             连接到hdfs的web路径 http://hadoop102:50070
             连接到yarn的web路径 http://hadoop102:8088
         (3)代码操作案例：
                 //1.首先连接到hdfs系统客户端
                 FileSystem fs = FileSystem.get(
                    new URI("hdfs://hadoop102:9000"), new Configuration(), "lisi");
                  //2.然后用fs客户端操作
                 fs.mkdirs(new Path("/lisi/lisi07"));
                ----------------------------------
            代码操作用法和hdfs程序很相似，概括就是先获取客户端，然后用获取的客户端操作
          （4）
                hdfs由NameNode，DataNode和Secondary NameNode组成
                一，其中NameNode相当于是数据的目录，是存储数据的元数据
                    如文件名，文件目录，文件属性，以及每个文件得块列表
                    和快的DataNode等
                二，DataNode存储真正的数据和块数据的校验和
                三,Secondary NameNode 用来监控hdfs的辅助后台程序，每隔一段时间
                    获取hdfs元数据的快照。


    2.mapreduce是分布式计算框架
        （1）
            不擅长实时计算，不擅长流式计算，数据源必须是静态的
        （2）
            Mapper阶段：
                map()方法（MapTask进程）对每一个<k,v>调用一次
            Reducer阶段：
                reduceTask进程对每一组相同k的<k,v>组调用一次reduce()方法
        （3）
            FileInputFormat切片机制：
                每一个Split切片分配一个MapTask并行实时实例处理，也就是
            有多少个split切片就有多少个MapTask。默认情况下切片大小=BlockSize。
            其次切片时不考虑不考虑数据集集体，而是针对每一个文件单独切片。
                比如：a.txt：200M  b.txt 10M
                    a.txt分成：0-128M和128-200M两个分片 。 b.txt 会分成0-10M一个分片。
                    所以共分成3个分片，也就是3个mapTask
          (4)
               提交jar方法 hadoop jar jar包路径  main类 输入路径 输出路径（要不存在，否则报错）
                    注意：如果开启了hdfs，那输入路径和输出路径直接用/就表示是hdfs的路径
                在idea里配置运行时，首先点击edit configuration，
                然后在program parameter里配置输入路径和输出路径，参数之间用空格分开，
                本地直接写相对路径和绝对路径就行，
                如果是hdfs，就写：hdfs://hadoop102:9000/输入路径 hdfs://hadoop102:9000/输出路径
     3.hadoop配置方式（看着word文档直接配，很简单）
        （1）本地模式：直接解压就能用，配置一台机器
        （2）伪分布式模式：配置一台机器,需要配置namenode主节点，yarn主节点，
         (3)完全分布式：配置三台机器，需要配置namenode主节点，yarn主节点，
            和在slave里配置上三台机器
      4.yarn（hadoop2.0以后才有）
         （1）2.0后yarn只负责资源的调度，MapReduce只负责运算。
                1.0时代MapReduce同时负责资源调度和业务处理，耦合性较大
          （2）yarn包括以下四部分：
               一，ResourceManager：（资源的分配，相当于盖房子的大包头，监控用户，小包头和手下的监工和分活的）
                    01.处理客户端请求
                    02.监控NodeManager
                    03.启动和监控ApplicationMaster
                    04.负责资源的分配和调度
                二，NodeManager（和单个节点资源管理有关，相当于公司各个小包头）
                    01.管理单个节点上的资源
                    02.处理来自ResourceManager上的命令
                    03.处理来自ApplicationMaster上的命令
                 三，ApplicationMaster（和任务运行有关，相当于大包头拍下来监工和分工的）
                      01.负责数据的切分
                      02.任务的监控和容错
                      03.为应用程序请求资源并给内部处理
                      03.任务的监控与容错
                  四，Container（单个节点资源抽象，相当于一个每个小包头的工作资源，如人力，干活工具）
                     （1）Container是yarn上资源的抽象
                     （2）它封装了某个节点多维度资源，
                            如内存，CPU,硬度，网络等。

                    我认为整个流程可以简单理解为，客户端首先将job任务提交到ResourceManager，
                  然后ResourceManager管理资源，和一些NodeManager单个节点资源管理者通信，
                  问他们是否可以运行这个job，如果可以，ResourceManager就让applicationMaster给NodeManager分配
                    任务，然后NodeManager拿到分配任务后，就利用手上的container资源干活。
                    同时Container干活受到ApplicationMaster的监控。


zookeeper总结：
    1.zookeeper是分布式服务管理框架
                 zookeeper = 文件存储+通知机制。
    2.通过zkServer.sh start 进入服务器端，如果是完全分布式那么三个节点都要打开此命令

    3.用zkCli.sh进入shell窗口，进入shell窗口后可以用help查看所有指令，然后很简单

    4.
        一.首先用ZooKeeper zkClient =new ZooKeeper(param1,param2,param3)获取客户端
        二.用如zkClient.delete("/fuxi/lisi02",-1)这样的操作操作zookeeper
           用法和hdfs程序很相似，概括就是先获取客户端，然后用获取的客户端操作


hive总结：

hbase总结


scala语言总结：
    1.安装（安装方法和jdk很相似）
        （1）安装scala语言之前必须先安装jdk，推荐jdk1.8
         (2)安装步骤
            （scala官网：https://www.scala-lang.org/）
            一,配置SCALA_HOME= D:\scala-2.11.8
            二，在PATH变量中添加：%SCALA_HOME%\bin
            三，打开cmd命令，输入scala打开scala解释器
            四，在idea工具上运行时需要在idea上安装插件
    2.只有object修饰的类里才能放main方法。以下是案例：
      object HelloScala {
      //main方法
        def main(args: Array[String]): Unit = {
          println("Hello Scala") // 打印字符串
        }
      }
    3.简介：
        （1）scala是一门多范式编程怨言，其中的范式指编程方式，
            不同的编程语言，编程方式也不同，也就意味着scala融合了
             多种不同编程方式的语言。所以Scala编程的初衷是集成面向对象
            和函数式编程的各种特性
        （2）Scala源代码(.scala)会被编译成字节码（.class），
        然后运行于JVM上，并可以调用java的类库，实现两种语言的无缝对接。

          项目里的target目录也用于存放程序运行后的.class文件，可以用jd-gui软件打开
    4.函数式编程：（函数式编程过程可以对比js代码学习）
         （1）它属于“结构化”编程的一种，主要思想是把运算过程写成一系列
       嵌套的函数调用。
         （2）函数编程语言最重要的基础是λ演算，而且λ演算的函数可以接受
         函数作为输入（参数）和输出（返回值）
          （3）几种语言区别：
                一，scala，java和js一样用{}作为代码块，python语言不同
                用：和空格区别代码块。
                二，scala和python都用def修饰方法。
                三，scala和js都用var修饰变量，区别scala还可以用
                     val表示常亮。python没有修饰变量的，直接写 a =10就行
                 四，scala，python和java是强类型语言，有返回值，js无返回值。
                       scala：
                            def  f1(): Unit ={
                                println("hello world");
                              }

                              def  f2(a:Int,b:Int) ={
                                a+b;
                              }
                       java：
                           public int sum（int a,int b）{
                                return a+b;
                           }

                        python:
                            def functionname( parameters ):
                               return [expression]

                 五.参数区别
                     python直接写变量就行，java是（int a），scala是
                      （a:Int）,如果方法没有参数，小括号可以省略。


              （4）Unit表示无返回值，和java的void一样。


              （5）方法相关
                   一，方法格式
                     def 函数名（参数名[：参数类型]…）[: 返回值类型 = ] {
                        函数体
                     }
                     解释：返回值类型为整个方法的返回值类型
                    二，关于返回值的几点说明
                      *如果函数无返回值，那么返回值类型无需声明
                      *如果函数有返回值，但返回值类型没有声明。
                      方法返回值Scala会自动推断
                     （函数方法会使用最后一行的结果作为函数的返回值,
                        Println函数的返回值是unit）
                      *如果函数有返回值，且使用return声明的，
                      那么返回值类型需要声明（即使有unit，矛盾了，但是也不会报错
                      但是return不生效，函数的结果就是括号）
                      *如果函数无参数列表，那么小括号可以省略
               （6） 变量
                    一，格式：var | val 变量名 [：变量类型] = 变量值
                        其中[]表示可要可不要
                        var关键字表示声明的值可以改变，
                        而val关键字声明的变量表示值无法改变
                    二，scala中所有的类型都是首字母大写的
                    三，一行逻辑代码的最后，无需使用“；”但是一行中
                        如果存在多个逻辑代码，必须使用“；”分开。
                    四，在函数式编程中，函数与其他数据类型一样，处于平
                      等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数
                      或者作为别的函数的返回值。（记住和变量使用方法一样就行）
                (7)面向对象（可以参考java）
                     一，类对比
                        java：
                           *格式
                               [修饰符] class 类名 {
                                    类体
                               }
                            *java语法中要求一个java源码文件中可以声明多个类，
                             但是公共类只能有一个，且必须和源码文件的文件名保持一致。
                        Scala：
                            *格式
                                 [修饰符] class 类名 {
                                    类体
                                 }
                             *scala语法中，类并不声明为public，
                             一个Scala源文件可以包含多个类。所有这些类都具有公有可见性
                      二，对象对比
                               java：
                                    格式
                                       // 类型 变量 = new 类型();
                                       // User user = new User();
                                       // Java是强类型语言，声明任何变量的同时都必须声明类型
                                scala:
                                    格式
                                        val 变量[:类型] = new 类型();
                                        val user:User = new User();
                                        scala在声明对象变量时，可以根据创建对象的类型进行推断
                                        所以类型声明可以省略
                        三，属性对比
                            java：
                                  * private 类型 属性名称；
                                  *public Setter/Getter方法
                                   *Java语法中如果声明了一个属性，
                                   但是没有显示的初始化，那么会给这个属性默认初始化
                                   *通过setter/getter方法对属性进行赋值和取值
                                    setter/getter方法一般都是公共访问权限，起到了封装的作用
                             scala:
                                  *  private var 属性名称 [：类型] = 属性值
                                  * def Setter/Getter方法
                                  *Scala中声明一个属性,必须始化，然后根据初始化数据的类型自动推断，属性类型可以省略，
                                      如果初始化的值设定为null，也可以使用符号_(下划线)代替
                                  *Scala为了访问一致性，所以并不推荐由开发人员自行定义setter/getter方法,
                                       Scala中为了简化代码的开发，当声明属性时，本身就自动提供了对应的setter/getter方法
                                  *如果属性声明为private的，那么自动生成的setter/getter方法也是private的
                                        如果属性省略访问权限修饰符，那么自动生成的setter/getter方法是public的
                         四 普通方法对比
                                java
                                    *public 返回值类型 方法名(参数列表) { 方法体 }
                                    *调用方法 对象.方法名()
                                scala
                                    *def 方法名(参数列表) [：返回值类型] = {方法体}
                                    *Scala中的方法其实就是函数，只不过一般将对象中的函数称之为方法
                                    *调用方法  对象.方法名()
                          五.静态方法对比
                                java(加static关键字即可)
                                    *public static 返回值类型  方法名(参数列表) {方法体}
                                    *java中静态方法并不是通过对象调用的，而是通过类对象调用的，
                                        所以静态操作并不是面向对象的。
                                 scala(样例代码还没有)
                                      *Scala语言是完全面向对象(万物皆对象)的语言，所以并没有静态的操作。
                                        但是为了能够和Java语言交互，就产生了一种特殊的对象来模拟类对象，
                                        我们称之为类的伴生对象。这个类的所有静态内容都可以放置
                                        在它的伴生对象中声明和调用
                                      *Scala中伴生对象采用object关键字声明，
                                       伴生对象中声明的全是“静态”内容，可以通过伴生对象名称直接调用。
                                       *伴生对象对应的类称之为伴生类，伴生类和伴生对象应该在同一个源码文件中
                                       *从语法角度来讲，所谓的伴生对象其实就是类的静态方法和成员的集合
                                       * 从技术角度来讲，所谓的伴生对象在编译时，
                                       会将对应的代码以静态的方式生成到类的字节码中。
                      （8）包







spark总结：（不用配置zookeeper）
        1.spark有三种运行模式：local本地运行模式,standalone模式和完全分布式模式
                (1)local模式(配置一台机器，直接解压就能用)

                (2)standalone模式(配置三台机器）

                (3)完全分布式模式（配置一台机器，然后让yarn实现分布式）
         2.用spark-shell打开spark的shell客户端，默认是本地模式
           spark-shell -master yarn 打开yarn模式

flink总结：

